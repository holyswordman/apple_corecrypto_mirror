	/* CAVS_VECTOR_CIPHER_ENC */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_CIPHER_ENC, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_ECB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 0, .extra = (uint8_t *)"", .gcm_auth = 0, .input_len = 16, .input = (uint8_t *)"\x01\x47\x30\xF8\x0A\xC6\x25\xFE\x84\xF0\x26\xC6\x0B\xFD\x54\x7D", .output_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x5C\x9D\x84\x4E\xD4\x6F\x98\x85\x08\x5E\x5D\x6A\x4F\x94\xC7\xD7";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_CIPHER_DEC */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_CIPHER_DEC, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_ECB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 0, .extra = (uint8_t *)"", .gcm_auth = 0, .input_len = 16, .input = (uint8_t *)"\x5C\x9D\x84\x4E\xD4\x6F\x98\x85\x08\x5E\x5D\x6A\x4F\x94\xC7\xD7", .output_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x47\x30\xF8\x0A\xC6\x25\xFE\x84\xF0\x26\xC6\x0B\xFD\x54\x7D";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_MONTECARLO_ENC_INIT */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_MONTECARLO_ENC_INIT, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_OFB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\x5C\xA3\x19\x8A\xAE\x0C\x00\xA6\x1F\xA5\xB3\x56\xF7\xA6\x57\xB8\x2B\x40\x29\xA4\x81\x30\xC2\xE1\xF5\x93\x99\x98\x5B\xFC\xC9\x08", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xA0\xFD\xCA\xA8\x6D\x71\x1F\xD4\xA2\xE6\xC7\x0C\xB1\xD5\xE4\x34", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
	/* CAVS_VECTOR_MONTECARLO_ENC_OP */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_MONTECARLO_ENC_OP, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_OFB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\x5C\xA3\x19\x8A\xAE\x0C\x00\xA6\x1F\xA5\xB3\x56\xF7\xA6\x57\xB8\x2B\x40\x29\xA4\x81\x30\xC2\xE1\xF5\x93\x99\x98\x5B\xFC\xC9\x08", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xA0\xFD\xCA\xA8\x6D\x71\x1F\xD4\xA2\xE6\xC7\x0C\xB1\xD5\xE4\x34", .gcm_auth = 0, .input_len = 16, .input = (uint8_t *)"\x0A\x53\x9F\xF2\x40\xB1\xC0\x1E\x52\xFB\xA8\x5A\x05\xEC\xF1\x66", .output_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x46\x11\xC8\xAD\x92\x94\x69\x1A\x1A\x1D\x84\x99\x67\xB6\xEE\x85";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_MONTECARLO_FINISH */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_MONTECARLO_FINISH, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_OFB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_UNKNOWN, .key_len = 0, .key = (uint8_t *)"", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 0, .extra = (uint8_t *)"", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
	/* CAVS_VECTOR_MONTECARLO_DEC_INIT */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_MONTECARLO_DEC_INIT, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_OFB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\xCC\x24\xC2\x2A\x97\x13\x46\xE8\xC7\x86\x20\xFD\xDA\x96\x56\x6D\x94\x86\x6C\xB9\x45\xF8\xCD\xB1\x4A\x60\x6D\x8A\xD6\xB8\xAD\x30", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xA1\x85\xDB\x85\x74\x18\x4A\x05\xCC\xC5\x62\xA1\x90\xEA\xD9\xC1", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
	/* CAVS_VECTOR_MONTECARLO_DEC_OP */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_MONTECARLO_DEC_OP, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_OFB, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\xCC\x24\xC2\x2A\x97\x13\x46\xE8\xC7\x86\x20\xFD\xDA\x96\x56\x6D\x94\x86\x6C\xB9\x45\xF8\xCD\xB1\x4A\x60\x6D\x8A\xD6\xB8\xAD\x30", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xA1\x85\xDB\x85\x74\x18\x4A\x05\xCC\xC5\x62\xA1\x90\xEA\xD9\xC1", .gcm_auth = 0, .input_len = 16, .input = (uint8_t *)"\x59\x2A\xBA\xEB\xE5\xC0\x83\x2F\x7D\x0E\x9B\x29\x0F\x17\x84\x9D", .output_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\xBB\x58\x86\x91\x94\x1E\x47\x8A\x99\x83\xA0\x0D\x0D\xFA\xEC\x25";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_HMAC_DRBG */
	{
		struct cavs_op_drbg v = {.vector = CAVS_VECTOR_HMAC_DRBG, .digest = CAVS_DIGEST_SHA1, .target = CAVS_TARGET_USER, .sha_is = CAVS_SHA_IS_GEN, .pred = 0, .ent_in_len = 16, .ent_in = (uint8_t *)"\xC0\xE5\x08\x30\x74\xED\xD4\x17\x17\xBE\xB2\x33\x77\x6E\xB2\x6F", .nonce_len = 8, .nonce = (uint8_t *)"\xE7\xD9\xE7\x32\x7C\x29\x49\x56", .pers_str_len = 0, .pers_str = (uint8_t *)"", .add_in1_len = 0, .add_in1 = (uint8_t *)"", .add_ent1_len = 0, .add_ent1 = (uint8_t *)"", .add_in2_len = 0, .add_in2 = (uint8_t *)"", .add_ent2_len = 0, .add_ent2 = (uint8_t *)"", .random_len = 80, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x8C\xA8\xE5\xA0\xB4\x88\x86\x52\x5D\xE3\x44\x8E\xCA\x01\x81\xA6\x78\xFC\x80\xE2\x18\x64\x84\x82\x42\x2F\xDA\xC6\x5E\xA8\x2C\x67\xC9\xFD\x1A\xEE\xDD\x28\x9E\x6C\xC8\xD5\x37\xC9\xF6\xB6\x5C\xDC\xA9\xE3\xF3\x32\x84\x1C\x99\x1A\x19\xD6\x9D\x6D\x12\x79\xCF\xDE\x6D\xBE\x9B\xCB\xF1\xDF\xC9\x23\x9F\xE4\xAB\x23\xC8\xC2\x0D\x76";
		is(len, (size_t)80, "expected length");
		ok_memcmp(exp_result, wksp, 80, "expected result");
	}
	/* CAVS_VECTOR_DRBG */
	{
		struct cavs_op_drbg v = {.vector = CAVS_VECTOR_DRBG, .digest = CAVS_DIGEST_UNKNOWN, .target = CAVS_TARGET_USER, .sha_is = CAVS_SHA_IS_GEN, .pred = 0, .ent_in_len = 16, .ent_in = (uint8_t *)"\x72\x87\xAE\x2F\xC9\x22\xAB\x8E\x01\x2D\x41\x4A\xD2\x3E\x30\x3B", .nonce_len = 8, .nonce = (uint8_t *)"\xC6\x3D\x51\x4C\x5A\xBF\x64\x76", .pers_str_len = 0, .pers_str = (uint8_t *)"", .add_in1_len = 0, .add_in1 = (uint8_t *)"", .add_ent1_len = 16, .add_ent1 = (uint8_t *)"\xF2\x5C\x0F\x7E\xD4\xD5\x7C\x86\xA0\xBA\x5B\x33\xA7\xD2\x90\xBA", .add_in2_len = 0, .add_in2 = (uint8_t *)"", .add_ent2_len = 0, .add_ent2 = (uint8_t *)"", .random_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x15\xE1\x2E\x54\xD9\x4A\x9D\x76\x49\x4D\x9E\xCF\x98\xA5\x1F\x57";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_EC_PKV */
	{
		struct cavs_op_ec_pkv v = {.vector = CAVS_VECTOR_EC_PKV, .key_sz = 256, .qx_len = 32, .qx = (uint8_t *)"\x5A\x15\x3A\xB9\x8C\xA3\x39\x86\x84\x31\xB3\x9B\x5E\xAB\x75\x49\x1D\x90\x7E\x04\x28\x55\xC4\x1B\x00\x91\xE4\x64\x21\xDC\xB1\x83", .qy_len = 32, .qy = (uint8_t *)"\xD7\x74\xB2\x24\x80\x48\xD7\x58\x2D\xE2\x14\xA0\x7C\x32\xD9\x51\xED\xC8\x64\x1B\x0F\x76\x39\xCA\x65\xC2\xDE\xE0\x00\xCC\xB6\x65", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x00\x00\x00\x00";
		is(len, (size_t)4, "expected length");
		ok_memcmp(exp_result, wksp, 4, "expected result");
	}
	/* CAVS_VECTOR_EC_SIG_VERIFY */
	{
		struct cavs_op_ec_sig_verify v = {.vector = CAVS_VECTOR_EC_SIG_VERIFY, .digest = CAVS_DIGEST_SHA1, .key_sz = 256, .qx_len = 32, .qx = (uint8_t *)"\xF0\xB3\x46\x37\x99\x86\xC3\xC0\xF8\x14\x02\x79\xB4\xC6\xFA\xA5\x9A\x14\xE5\x19\xAD\x5D\xAC\x53\x86\xB4\x75\x65\x16\x38\xA3\xDE", .qy_len = 32, .qy = (uint8_t *)"\xA5\xBC\xB3\xEB\x6F\xDE\x88\xE0\x27\x6F\x6F\xE9\xDA\xE6\x58\x43\x53\xE2\xDE\xD9\xCC\x81\xF7\x85\x59\xA6\x88\x31\x28\x7E\x4B\x30", .r_len = 32, .r = (uint8_t *)"\xF2\xC5\xE9\xC2\x4D\xD6\x03\x1B\xA7\x49\x35\x51\xBD\xF7\xEF\x9F\x1C\x3A\xFF\x19\xA5\x23\xC5\x8B\x34\x48\xDA\x38\xFC\xB1\xEF\xA5", .s_len = 32, .s = (uint8_t *)"\xCB\x44\x28\x79\x6E\x88\x56\x62\xCB\xCD\x3A\x14\x32\x44\x78\x30\xCE\xB4\x37\xAD\x4B\x4F\x8C\xC5\x35\xD1\x77\xF2\x21\xF3\xB4\xE2", .message_len = 128, .message = (uint8_t *)"\x45\x45\x71\xF0\x80\xBE\x34\xBF\xD1\xEE\x4F\xAF\x46\xA4\x27\x6F\x5D\x5B\x07\x11\xAB\x3C\x46\x6C\x26\x0C\xDF\xA9\x14\x2E\x86\x40\x4E\x7E\x92\x68\x75\x2E\xBE\xE4\xB3\xE0\x92\x37\x53\xA6\x2D\x0D\xCF\xA5\x21\x93\x4A\x99\x9E\x85\x29\x09\x2B\x2C\x92\xC4\xA2\xA6\xFD\xB4\x33\x0E\x73\x13\x29\xEB\x31\x25\xA4\x35\x1C\x7B\xE0\x1E\xC9\xA4\x4C\x01\x4E\x5D\xF2\x86\xC2\xE1\xD2\xEA\x1D\xB1\xA3\x0E\xCB\x00\x0D\x82\xC0\x51\x0C\x43\xD6\xD1\xF5\x7E\xB1\x75\xC7\xE5\xCA\xA4\x76\xCD\x3C\xD5\xBB\xEA\x70\x31\x81\x10\x3F\xCD\x43\xE9", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x00\x00\x00\x00";
		is(len, (size_t)4, "expected length");
		ok_memcmp(exp_result, wksp, 4, "expected result");
	}
	/* CAVS_VECTOR_HMAC */
	{
		struct cavs_op_hmac v = {.vector = CAVS_VECTOR_HMAC, .digest = CAVS_DIGEST_SHA1, .sha_is = CAVS_SHA_IS_GEN, .key_len = 50, .key = (uint8_t *)"\xF7\xE4\x7F\xBB\x51\x5D\xC2\x27\xAB\xB9\xAC\xAD\x8F\xEF\xAA\x14\x77\x1B\xB7\x7B\xD7\x74\x7E\xEF\x5E\x7E\xC3\x39\x79\x81\xFF\xF9\x1A\x39\x4A\xF9\xB7\xCF\x7E\xBB\x95\x08\x9A\x54\x46\xBD\x64\x7D\x71\x8B", .message_len = 128, .message = (uint8_t *)"\x2E\xD9\x13\xE1\x73\x79\x25\x13\xE8\x3E\xAD\x40\x53\x67\x36\xD5\x3F\xE0\x4F\x3A\x44\x75\xE9\xA8\x88\x40\x00\x3B\x86\x63\x7E\x48\x0E\xFD\x5C\xF0\x8D\x56\x0A\xF5\x8F\x5D\x11\xCD\x82\x55\xF7\xF5\xBD\xCB\x62\x88\xC1\xCB\x81\x10\xBE\x53\xA8\x9C\x59\x08\x3A\x13\xAC\x28\xCC\xC7\x8E\xC0\x87\x4D\x15\x1F\xCE\x8D\x5A\x8A\x21\x15\x7C\x31\x42\xB3\xE8\x62\x96\x42\xD7\xFD\xCD\xC4\x18\x28\xC6\xB1\x0F\x43\xAC\x8F\xFE\x1F\x66\xC3\x83\x6A\x2E\xA7\x62\x6E\x7F\xDC\x85\xFC\x35\xE2\x41\xA2\xF0\xE5\xDB\x24\xB9\xDA\x4B\x2A\xE8\xCB", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x2D\xEC\xD5\x06\x02\x75\x78\xBD\x41\x04\xB5\x6F\x2F\x68\x0B\x96\xE6\xE2\x26\x4D";
		is(len, (size_t)20, "expected length");
		ok_memcmp(exp_result, wksp, 20, "expected result");
	}
	/* CAVS_VECTOR_EC_VAL_RESP */
	{
		struct cavs_op_ec_val_resp v = {.vector = CAVS_VECTOR_EC_VAL_RESP, .key_sz = 256, .pub_x_len = 32, .pub_x = (uint8_t *)"\x82\x15\xFE\x84\x3B\xA5\xBA\xE1\x69\x93\x30\xF1\xB3\x92\x67\x57\x4D\x38\x37\xA8\xBB\xEC\xDC\x55\xB4\x8C\xD9\xF9\x33\x50\xDA\x55", .pub_y_len = 32, .pub_y = (uint8_t *)"\x94\xFE\x32\xF3\x98\x11\x4C\x0B\x35\x21\xB1\x08\xB7\x65\x57\xB6\x74\x1D\x08\x06\x03\xA5\xA4\x80\x40\x9B\x3E\xC8\x18\x50\xA0\x09", .priv_x_len = 32, .priv_x = (uint8_t *)"\xB0\x0D\x44\x8E\x08\xCC\x19\xCF\x2F\x30\x30\x58\x07\x51\xBE\xAE\xB2\x29\x6A\x70\xE8\x4B\xD4\x27\xF8\x03\x73\x19\x32\x9C\xB2\xC1", .priv_y_len = 32, .priv_y = (uint8_t *)"\x5B\x91\x41\xC4\xB0\x82\xCC\x80\x9E\x33\x9E\xBE\x8A\xEC\xC0\x4E\x56\xFC\x3E\xAE\xC6\xAF\x4A\xFC\xC2\x10\xFC\x9F\xF7\x2E\xDE\x8E", .priv_k_len = 32, .priv_k = (uint8_t *)"\x9B\xC7\x92\x3E\xE2\x0C\xF4\xF0\x39\x76\x79\x6D\x82\xDA\x6A\x01\xFD\xFA\xAF\xEF\xF4\xA5\x8D\x28\xA7\xBB\xAF\x6E\x25\xA1\x15\xCF", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x20\x00\x00\x00\x8A\x6D\x50\x32\x7F\xC3\x8E\xCA\x57\x58\xC6\xC8\x68\xD4\x61\xD6\x2D\x5E\xAE\x36\xAF\x63\xEA\xCA\xDD\x8F\xBE\xDC\x9B\xBA\x54\x7B";
		is(len, (size_t)37, "expected length");
		ok_memcmp(exp_result, wksp, 37, "expected result");
	}
	/* CAVS_VECTOR_EC_VAL_INIT */
	{
		struct cavs_op_ec_val_init v = {.vector = CAVS_VECTOR_EC_VAL_INIT, .key_sz = 256, .rng_len = 32, .rng = (uint8_t *)"\xFE\xCA\xC2\xD9\xB1\xD5\x8C\x3D\x70\x44\x98\x48\xB0\x9A\xAD\x8A\xDD\xA3\x56\x55\xFC\x68\x02\x31\x7A\x04\xEF\x31\xE5\xB6\x74\xDB", .pub_x_len = 32, .pub_x = (uint8_t *)"\xFF\xBB\x6F\xAB\xB2\xFE\x96\x50\x12\xB5\x32\xBB\x01\x46\x11\xFE\xA0\x84\xE9\xD6\x55\xE6\x67\x61\x0D\x56\x86\x68\x86\x5C\x6B\xD2", .pub_y_len = 32, .pub_y = (uint8_t *)"\xD4\xC2\xEF\x9C\x49\x63\x14\x2B\xA9\x1F\x95\x3A\xAF\x0A\x42\x2B\xF5\x9E\xA6\x75\x6B\x69\x98\x43\xEE\xF7\x03\xD8\x57\x43\x4B\x0B", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x20\x00\x00\x00\x9E\x80\x3B\x6C\xC3\x5F\x7D\x84\x58\x5B\x01\x45\xD1\x98\x24\x35\xC5\x45\xFF\xCC\x91\xC5\x11\xEE\x51\x5F\xB2\x6C\x74\x5D\x2C\xB8";
		is(len, (size_t)37, "expected length");
		ok_memcmp(exp_result, wksp, 37, "expected result");
	}
	/* CAVS_VECTOR_AES_KW_DEC */
	{
		struct cavs_op_aes_kw v = {.vector = CAVS_VECTOR_AES_KW_DEC, .key_len = 24, .key = (uint8_t *)"\xA7\x4D\x99\xD7\x19\x4F\xDF\x7E\x92\xE5\xA6\x3A\x56\x59\xA3\xD8\x97\xAA\xE7\x8B\x43\x8C\x1D\x21", .data_len = 24, .data = (uint8_t *)"\x96\x82\x3F\x7E\x5C\xAC\xC5\x06\x64\xAF\x14\xC3\x2D\x65\x03\x4A\x58\x47\xA2\x23\x74\xBF\x85\x08", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x00\x00\x00\x7F\x63\xD4\x2F\xF5\x4A\x72\xA7\xB5\xB5\x14\x3B\xCC\x72\x70\xD4";
		is(len, (size_t)20, "expected length");
		ok_memcmp(exp_result, wksp, 20, "expected result");
	}
	/* CAVS_VECTOR_AES_KW_ENC */
	{
		struct cavs_op_aes_kw v = {.vector = CAVS_VECTOR_AES_KW_ENC, .key_len = 16, .key = (uint8_t *)"\x60\x5F\x68\x85\x40\xA9\xBD\xBC\x4B\x7D\x64\xE3\x23\x08\x3A\x88", .data_len = 16, .data = (uint8_t *)"\xEC\xC1\x68\xE3\xD8\xA6\xE8\x49\xB6\x23\xAA\x05\x4B\x05\xDD\x2C", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x00\x00\x00\x5B\x71\x1D\xCC\x4A\xD2\x2E\xC8\x56\xF0\x9C\x3E\xAC\x86\x1F\x9B\x68\x26\x3B\xF4\x05\xAB\x49\x06";
		is(len, (size_t)28, "expected length");
		ok_memcmp(exp_result, wksp, 28, "expected result");
	}
	/* CAVS_VECTOR_RSA_VERIFY */
	{
		struct cavs_op_rsa_verify v = {.vector = CAVS_VECTOR_RSA_VERIFY, .digest = CAVS_DIGEST_SHA1, .key_sz = 1024, .modulus_len = 128, .modulus = (uint8_t *)"\xDF\x38\xD9\xDB\x8D\x47\x2A\x8F\x2D\x4F\xDC\xCA\x28\xE4\xDC\x72\xD7\xF8\xA1\x27\x41\xA9\xC0\xF4\xF7\x3F\xEF\xD5\xE4\x24\x9E\xD8\x92\x6C\x8D\xE8\x77\x03\x0A\x3E\x1A\xBB\xAA\xD2\xE7\xFF\x7F\x05\x86\xF6\x47\xBB\x30\x38\xFA\x0D\x17\x48\x52\x01\x63\x7A\xE4\xC2\x5B\x14\xD2\x5F\x13\xF6\x27\xD7\x67\xC8\xFF\x04\x69\x05\xD5\x2B\x00\x07\xD1\xE6\x7D\x71\xA5\xE3\x9F\xDA\x09\x40\xD7\xB0\x19\x77\x7A\x4E\xC2\xDA\xA6\xD7\xB1\x37\x46\x8C\x6C\xDE\x1F\xDF\x19\xBD\x6B\xEE\x34\xF6\xE8\x8A\x2C\x1D\x54\x73\x20\x70\x07\x39\xD6\x17", .exponent = 2785437, .message_len = 128, .message = (uint8_t *)"\xC9\x25\x07\xF1\x37\x48\x9F\x69\x4B\xD6\xD2\x7B\x56\x31\x89\x39\xB1\x9D\x0A\xA1\xF4\xA3\xCD\x1F\x69\xB4\x8A\x54\xC1\x0F\x97\x16\x05\xE5\x71\xB8\xCF\xBA\x99\x8B\xB9\x0E\xA1\xA4\x16\x3D\x86\xE0\xE0\xA4\x40\x26\xF2\x05\x98\xEC\x77\x2C\x3A\xFD\xA3\xD3\x0B\x79\xA1\xC4\xBC\x1D\xCC\x3D\xA0\xC4\x21\x98\xBA\x2E\xF4\x2B\x1B\x01\xE3\x6E\x6B\x0D\x09\x5B\xC5\xD4\x74\x1B\xC8\x4A\xD8\xDE\xEA\xD9\x84\x0B\x10\xA8\x96\x99\x5C\x1D\x6B\xBC\x46\xA1\x5A\xC5\xEF\xA3\xA2\x43\xB1\xDF\xA0\x6F\xFB\xE0\x46\xC7\x5C\xC3\xC8\xF8\xDD\x3F", .signature_len = 128, .signature = (uint8_t *)"\x3C\x3B\x7B\x9D\x75\x68\x4E\x91\x70\xA2\xAA\x65\x4C\xE0\x37\xEA\xA7\xDA\x0F\x50\xC5\x83\x42\xB3\x6D\x71\x3E\xDC\x80\xF5\x35\x5F\xAB\x9E\xB0\x7F\xA3\xE6\x54\xC9\xF2\xC4\x17\x33\xAD\x27\x80\x07\x78\x5F\x78\xB3\xBC\xDD\xE6\xE7\xBF\x4A\xEA\x81\xDF\x5D\x37\x25\xC3\x91\x16\x20\xEB\x14\xFC\x68\xD3\x6C\x18\xF0\x66\xE1\x9E\xEF\xC8\x58\xC3\x19\x38\xC6\x34\x30\xA8\xA9\xD1\x0F\xF7\xF8\x32\xE2\x08\xEC\x18\x14\xCF\x9E\xA2\xF8\x61\xD0\x7C\x4A\x6D\xD9\x1D\xB9\x54\xFB\xE5\xE8\xD9\x78\x2C\xDF\xBA\xB8\x3B\x7E\x07\xB8\xFC\x24", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x00\x00\x00\x00";
		is(len, (size_t)4, "expected length");
		ok_memcmp(exp_result, wksp, 4, "expected result");
	}
	/* CAVS_VECTOR_RSA_SIG_GEN */
	{
		struct cavs_op_rsa_sig_gen v = {.vector = CAVS_VECTOR_RSA_SIG_GEN, .digest = CAVS_DIGEST_SHA224, .key_len = 1191, .key = (uint8_t *)"\x30\x82\x04\xA3\x02\x01\x00\x02\x82\x01\x01\x00\x9C\x90\xCA\x2D\xB7\x2E\xB4\xFB\x6E\x60\x59\x3F\x01\xEA\xA1\x94\xDA\x5E\x32\x24\x31\xB9\x99\xF7\xB3\x1E\x0F\xA6\x5C\x15\xFA\x63\x70\xC0\xC5\xC8\xC9\x75\x00\x7E\xE4\x09\xAF\x37\x2A\x6F\x3E\x90\x09\x27\x5F\xF3\xCE\xE1\x80\x34\xA6\x89\xD2\xF1\xD6\xA8\xD5\xB4\x9F\xCF\xCC\xE7\x48\xF9\x96\xC5\x87\x4E\x88\xFF\x5D\xE8\x48\x26\xD4\x2A\xB0\x35\x46\xB4\x3D\xD8\xC6\x9F\xF1\x9E\x94\xD7\x7D\x7E\xC3\x1B\x83\xD6\x50\x45\xD4\x9F\x03\x85\xAC\x80\x46\xE5\x40\xF2\x0A\x06\x96\xA6\x65\x7F\x56\xA8\x9B\x7D\xDB\xB0\xAE\x2A\xEA\xFA\xD3\x56\x5C\x70\xCB\x5D\xD9\xB9\xB1\x68\x27\xBD\x97\xF6\x39\x41\x29\xE4\x55\x9E\xCF\x91\x15\x72\x31\xF1\x82\x84\x79\x77\x1F\x46\xDF\x99\xAA\xC7\xC5\x54\xC8\x8B\xFE\x90\x31\x88\x7A\xFC\x2E\x9F\x61\x12\x97\xB5\x4B\x99\xE9\x37\x77\xD4\xF6\xF9\xD9\x52\x00\x2C\x05\x67\x6B\x7A\x86\x99\xD3\x2A\x7C\x38\xE8\x55\x91\x60\xDC\x6A\xD5\xB1\x40\x65\xC1\xD8\xC0\x04\xEA\x19\xC6\x98\xC8\x59\xD9\xA6\x09\x40\xBE\x17\xD1\x76\x19\xD7\xB3\x46\xB8\x19\x24\x14\x7A\x64\xB0\x03\xEC\x5E\x25\xF6\xAA\xB6\x9B\x9B\xF7\xB2\xA7\xE9\x3B\x2F\x02\x03\x01\x00\x01\x02\x82\x01\x00\x44\xF2\xF8\xAE\xB0\x4C\xD7\xF4\x20\x74\x3A\xE9\x66\x11\x2B\xCE\x8F\x6A\x4B\x3F\xA8\x4C\x59\xF3\x7D\x44\xC0\x54\x9D\x9A\x2A\x36\x2F\xBA\x1D\x80\x22\xC4\x2D\x8F\x34\x22\xD5\xB0\x80\x36\x14\x81\xBF\x1E\x41\x81\xEF\xFA\x5C\x09\x13\xCC\x7F\x82\xF4\x6B\x4F\x0D\xE8\x11\x4D\xE6\x0F\x3B\xA7\x7B\xDE\xEE\x25\xA3\xFC\x79\xA6\x88\xBF\x07\xFB\xA8\xC2\xB5\xEE\xC4\xB0\x18\x51\x02\x6A\xFF\x09\x6B\xD1\x45\xA5\x46\x34\xFC\xC3\xB9\xB1\x85\xE5\x65\x6A\x93\x5C\x8A\x1B\x03\x32\xC6\x1D\xCD\xB9\xDE\xAF\xF7\x79\xCF\xF1\xAB\xC1\xE6\x3A\x55\x7C\x33\x13\x41\x3E\xDC\xC0\xFC\xAB\xEA\x8F\xFA\x12\xA1\x8E\x45\xC0\xEF\xCC\x3E\x33\x92\x1C\x20\x02\x4A\x56\x42\xE9\x52\xDC\x2F\x64\x74\x8D\xC0\xCB\xD3\xCE\x1E\xF9\xD8\xBA\x90\x33\x46\x32\x82\x3C\x0E\x18\x9E\x41\x55\x44\x9C\xFE\xFA\x29\x84\x87\xFB\xC2\xA1\xEB\xDE\xD7\x5D\x7C\xBB\xA7\x67\xCA\x51\x4C\x95\xFA\xC0\xFB\xD8\x87\xDF\x90\x7C\xF3\xBC\x08\xED\xBB\x26\x7E\x9E\x13\x4C\x9F\xFE\x1D\x51\xC8\xC9\x75\x12\x6F\x0F\x26\x96\x4F\xB3\x29\x6E\x46\x52\x0E\xC5\x70\xF5\x42\xCA\xCF\x55\x4B\x7C\xF0\x66\xF2\xD5\x02\x81\x81\x00\xD8\xD6\x8C\x4A\x7E\x09\x51\xD6\xA2\xD2\x8C\x33\x00\x0E\xAE\xD8\x1C\x32\x11\x5A\xA3\x16\x25\xE2\x91\x4C\x6C\xB8\x0F\x73\x00\x6F\xFA\x8C\x54\x9D\x61\x78\xEE\xE6\x98\x53\x36\x21\xD7\x5E\x8F\x66\x60\x9F\xC8\x74\xB3\x0E\xB5\x53\x27\x5D\x52\x50\xD6\xF9\x7B\x9F\x1D\x47\x34\x0C\x86\x93\xD5\x78\xB2\x17\xE5\x09\x1D\x36\xF6\xE2\x48\x45\xD9\x21\x87\x25\xA0\x47\x00\xB9\x4A\xAF\x34\x2E\x27\x6F\x6A\x5B\x0C\x7F\x86\x6B\x2F\x16\x3F\x12\xC5\xC3\xD3\xB0\xC9\xEE\xEF\x81\x69\x1E\xB8\xBC\xDE\xA5\xB0\xC1\x30\xF3\xA7\x6A\xD0\xEB\x02\x81\x81\x00\xB8\xD7\x8F\x0A\x0A\xF6\x60\x11\xDB\x2C\xC2\xDF\x82\xC1\xDE\x79\x62\x49\x4B\x1D\x0A\xD9\x8D\x9C\xA4\x76\x5A\xC5\xC7\x68\xF6\x4F\x6B\x64\xE2\xDB\x53\x71\x1C\xEA\x35\x5C\xC0\x02\xA8\x6A\x3C\x40\xB0\x82\x38\x75\xD4\xEE\x82\xD5\x8C\xFF\x7B\x31\x18\xAC\x95\x2B\x8C\x96\x1C\x85\x37\x10\x1D\x7B\xAE\x81\x06\x0E\x70\xBC\xC5\x64\xBA\xF1\xC5\xB4\x3A\x17\x8B\x0A\xAD\xF8\xF5\x2E\x2A\xEF\xDF\x9F\x0C\x66\x28\xAA\x7D\x27\xDC\x64\x4A\xAC\x4E\x5A\xD8\xA8\x9D\xD3\x24\x35\xA2\xD3\x25\x0D\xBB\xC3\x32\xA3\x5E\x0C\x2F\x4C\x0D\xCD\x02\x81\x80\x43\x42\xE2\x07\xA5\x6A\xEC\xA8\xE0\x9E\xE1\x00\x5C\xEF\x31\x0B\x36\x4B\xCD\x98\x48\xE8\x70\xDE\x03\xE6\x29\xFF\x3A\x43\x99\x0A\x23\x34\xEE\x76\x57\x2A\xF5\x28\x30\x6D\xF7\x67\xAD\xEF\xD6\x19\x92\xB5\x5D\xAF\xDD\x6F\x1D\x8D\xEA\xB3\x06\xFA\xAE\x84\x7A\xF5\x53\x56\xA7\xED\x8E\xBD\x42\xC5\x8A\xB0\xE0\xC9\xDF\xF7\x11\xC4\x05\x59\x2D\x4E\x3A\x26\xD0\xBD\xD5\x9A\xA4\x71\x0E\x85\x96\x93\xF7\xF0\xC0\x42\xBA\x86\x7A\xF7\xB2\x9E\xF7\x1B\x94\x89\xCD\x49\xC1\x9F\x69\xE5\x2E\xB6\xDF\x75\x94\x0B\x89\x4C\xBB\x4C\xE5\xFB\x02\x81\x81\x00\xB2\x0C\xEA\x3B\x39\x4E\x14\x42\x7F\x06\x81\xFC\xBD\x3E\xB4\x67\xE6\x96\x45\x65\x87\x63\x02\xB7\x25\xF0\xE0\x05\x6D\xCD\x9C\x9D\xEA\x0C\x37\x3E\x20\x05\x70\x5D\xE6\xE3\x1E\x0E\x31\x5E\x8C\x05\xA0\x40\xFF\xD3\xF9\x35\x7B\x0F\xEC\x0E\xD9\x02\xF5\x0A\xA1\x72\x5E\xAC\xE6\x72\x28\x15\x3C\xE1\x3B\xBA\x0B\x34\x73\xC2\x52\xBE\x72\x19\x9C\x60\xBC\x28\x9B\x85\xC1\x09\x74\x5B\x71\x7E\xB8\xC0\xC3\x37\xD0\xEA\x51\x3E\xC9\x5C\x4E\x55\xE5\xF0\x3A\x8D\x49\xE1\xEE\x1A\x40\x6A\xF5\x61\x62\x41\x68\x10\xD7\xF2\x12\xC9\x46\xED\x02\x81\x80\x7E\xA8\x83\x8C\x40\xC7\xAD\xD1\x58\xBC\x58\xB7\x6B\x1F\x55\x84\x63\xBF\x31\x6B\x0D\xF6\xF7\x93\xD2\x6E\x9F\x60\x4A\x26\x92\x09\x4A\x53\xD6\x15\x27\x11\x58\x13\xF3\x6B\x40\x9C\x2E\xE3\x5A\xE3\xEB\x43\x70\xBE\x71\x71\x08\x53\x84\x4C\x5C\x47\xC4\x4A\x60\xEC\x07\xEB\x12\x23\xDA\x93\x08\x90\x2E\xFD\x14\xDB\xBF\x63\xB8\x4C\x6C\x59\xEF\xA0\xC5\xDE\x5C\xE1\x22\x00\x9C\x5E\x9D\xF7\xEB\x72\x72\x86\x9E\x4D\xAB\x3B\xA1\xCC\xD6\xCF\x7D\x76\x43\xA4\x35\xC9\x61\x50\x2F\xA9\x8D\xCD\x49\x83\x4F\xE3\x7C\x9B\x8A\x99\x51\x95", .message_len = 128, .message = (uint8_t *)"\xD2\x02\x5C\xB9\xCF\xB9\x6C\x33\xAA\x8C\x05\x6B\x37\x8D\x46\x1A\x13\x79\x4B\xFB\xE4\xE7\x96\x96\xE2\xC5\xB3\x56\x97\x05\x1B\xE2\xE2\x94\x5A\xAA\x42\x8C\x6D\xC0\x51\xAA\x6E\xEA\x8F\x02\x73\xF5\x61\xF1\xB3\x4C\x5A\x54\xEA\xC9\xB8\xF7\xFF\xCA\x32\x51\xE4\x88\xF1\x6E\xBF\xA4\xDC\x2C\x47\x03\x18\xAA\x70\xDC\xCF\xFE\x4A\x0F\x31\x26\x26\xB9\xB9\x41\xFC\x05\xB2\x00\x09\x45\xF9\x57\xBC\x41\x04\x78\xD3\xCE\x23\x01\xC2\xA3\x06\x74\x54\x69\x80\xE9\x94\x11\x8A\xFF\xEE\x6A\x8B\x18\x92\xF3\xD7\xC6\x19\xEE\x75\x80\x6B\xB5", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x35\x95\x7C\x68\xEE\x99\x1B\x49\x4B\xA5\x17\x04\x09\x9D\x1B\xDF\x2D\x65\x0B\xAE\xA2\xD6\xC6\x5A\x08\x72\x90\x32\x81\x71\xAA\x9F\xAB\x71\xA4\xF9\x7F\x47\x45\xC9\x25\x00\x7C\xAE\x4F\x7B\x3E\xA0\x2D\xD8\xC5\x70\xCD\xA2\x56\x49\x9E\x59\x3B\x30\x99\x1B\x23\x40\x60\x51\xA7\xB9\xF3\x9D\xE9\x69\x19\xE5\x34\x7F\xEE\xD9\x3D\x28\xBB\x68\xA7\x68\x9C\xC8\x40\x2C\xA3\x39\x9E\x1A\xA2\xC0\xAC\xD7\x16\x4D\x99\x9D\x67\xFA\xA6\x78\x5A\x5A\x44\x9E\x31\x9E\x67\xD5\xFB\xFA\xD1\xC9\x06\x56\x91\x0D\xBB\xEE\xB7\x79\xF8\xB3\xE7\xB6\xD7\xF4\x55\x03\x38\xE0\x37\xF2\x04\x65\xF4\xB1\xDB\x2A\x3A\x92\xF9\x4D\x04\x1F\x10\xA2\x80\xE4\xFE\x9E\xA7\x1E\x29\xB2\x65\xD9\xE2\xB6\xF7\x8A\xE7\xD1\xF3\xC3\xDE\x79\x33\x3D\xA0\xA3\x37\xC5\x0D\x63\x4A\x02\xB1\xA7\x23\xD3\x79\x95\x10\x32\x5A\x11\xC5\xDA\x2D\x49\xEA\x43\xE4\x4D\x9A\x2A\xB1\xE5\x26\x40\x62\xA5\x37\xCA\xD2\xC1\x29\x2A\x8C\x5B\xEB\x3F\x82\x1C\xD5\xC8\x0C\xDA\x26\x65\xD0\x02\x8A\x94\xAC\x0B\x92\xDF\xF8\x35\x5A\xF4\xCB\x84\xBD\x03\xA6\x3C\x5C\x93\xF0\xAE\x08\xDB\xF8\xAC\xA2\x1D\x4D\xE2\x88\xD8";
		is(len, (size_t)256, "expected length");
		ok_memcmp(exp_result, wksp, 256, "expected result");
	}
	/* CAVS_VECTOR_DIGEST */
	{
		struct cavs_op_digest v = {.vector = CAVS_VECTOR_DIGEST, .digest = CAVS_DIGEST_SHA512, .sha_is = CAVS_SHA_IS_GEN, .message_len = 192, .message = (uint8_t *)"\x0A\xE2\x91\x51\x5B\x4B\x83\x35\xC2\x23\x13\x79\x5C\x63\x6A\x6F\xC5\x86\x24\x17\x8B\x33\x5E\xE6\xE3\x1C\x10\xC7\x9B\x26\x9E\x60\x50\xCA\xA9\x96\xE1\xBB\x2B\x53\x23\xC9\xC3\x86\xD7\x05\x4D\x6C\xD9\x26\xB6\x0F\x9A\x2B\x0E\x0C\xCF\x42\xDF\x98\x6B\xE9\xBE\xC5\x0A\xE2\x91\x51\x5B\x4B\x83\x35\xC2\x23\x13\x79\x5C\x63\x6A\x6F\xC5\x86\x24\x17\x8B\x33\x5E\xE6\xE3\x1C\x10\xC7\x9B\x26\x9E\x60\x50\xCA\xA9\x96\xE1\xBB\x2B\x53\x23\xC9\xC3\x86\xD7\x05\x4D\x6C\xD9\x26\xB6\x0F\x9A\x2B\x0E\x0C\xCF\x42\xDF\x98\x6B\xE9\xBE\xC5\x0A\xE2\x91\x51\x5B\x4B\x83\x35\xC2\x23\x13\x79\x5C\x63\x6A\x6F\xC5\x86\x24\x17\x8B\x33\x5E\xE6\xE3\x1C\x10\xC7\x9B\x26\x9E\x60\x50\xCA\xA9\x96\xE1\xBB\x2B\x53\x23\xC9\xC3\x86\xD7\x05\x4D\x6C\xD9\x26\xB6\x0F\x9A\x2B\x0E\x0C\xCF\x42\xDF\x98\x6B\xE9\xBE\xC5", .digest_len = 64, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x7B\x19\xA3\xB4\xEA\xC1\x6A\x6A\xFD\xEF\xF1\xF4\x54\xE4\xAD\x00\xBC\xE0\x8D\x51\x2C\x23\xC9\x15\x42\x1B\x31\xCB\xBF\xDA\x66\xD3\x6A\xC9\x8F\x91\x50\xEC\x01\xF4\x2C\x30\x8E\x03\x61\x04\x11\x6B\x7E\x83\xB8\x32\x03\xD8\x33\x63\x77\x64\xC6\xAC\x24\xC1\xF3\x44";
		is(len, (size_t)64, "expected length");
		ok_memcmp(exp_result, wksp, 64, "expected result");
	}
	/* CAVS_VECTOR_EC25519_VERIFY_SHARED */
	{
		struct cavs_op_ec25519 v = {.vector = CAVS_VECTOR_EC25519_VERIFY_SHARED, .curve = CAVS_CIPHER_CURVE_25519, .pub_key_len = 32, .pub_key = (uint8_t *)"\x97\x5B\x88\xAF\x29\xE8\x4E\xB1\x3C\x3B\x6F\x1B\x5F\xA0\xCB\x66\x64\xE0\xE8\x07\x7C\x2B\x20\x87\xD1\x8E\x6A\x76\xC4\x34\xA5\x51", .priv_key_len = 32, .priv_key = (uint8_t *)"\x9F\x8A\xB1\x9F\xBC\x39\x41\x16\xE5\xA0\x39\x83\x56\x89\x53\xE8\x95\x59\xB9\x8B\x0D\x3A\x28\x1E\x8B\x29\x46\xED\x1C\x0F\xEE\x40", .eph_pub_key_len = 32, .eph_pub_key = (uint8_t *)"\xB6\xED\xDD\xA1\x59\x65\x4D\xBB\x6D\x85\x54\x67\xBD\x61\xAC\xFF\xF3\xFD\xF0\x94\x01\xB7\xA3\x8B\x1B\xE3\x83\xED\xA8\xE8\x00\x5E", .eph_priv_key_len = 32, .eph_priv_key = (uint8_t *)"\xDB\xBD\xF3\x67\x5A\x4F\xE2\x64\xAE\x7F\x61\x7C\xB7\xC8\xB6\xED\x8D\xAA\xCE\x11\x09\x50\x6A\x1F\x67\x58\x7F\xB8\x2E\x60\x73\xFD", .shared_len = 32, .shared = (uint8_t *)"\x7D\xA2\x32\x61\x60\x49\x66\xFB\x5D\x62\x2B\x84\x71\xCD\x6E\xC8\x63\x54\xDC\x82\xC7\xD3\x12\x3A\xC5\x6C\x3F\xA2\x86\x9D\x91\x0C", };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01\x00\x00\x00";
		is(len, (size_t)4, "expected length");
		ok_memcmp(exp_result, wksp, 4, "expected result");
	}
	/* CAVS_VECTOR_XTS_ENC_INIT */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_XTS_ENC_INIT, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_XTS, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\xF1\x48\x28\xDF\xD6\x3F\x10\x98\x8C\xAD\x14\x14\x6B\x7F\x81\x25\x03\xC1\x21\x4C\xAB\x4E\x6C\xE4\x9F\xFC\x05\x9E\x38\xEA\xEE\xE8", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xEC\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
	/* CAVS_VECTOR_XTS_OP */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_XTS_OP, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_XTS, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_UNKNOWN, .key_len = 32, .key = (uint8_t *)"\xF1\x48\x28\xDF\xD6\x3F\x10\x98\x8C\xAD\x14\x14\x6B\x7F\x81\x25\x03\xC1\x21\x4C\xAB\x4E\x6C\xE4\x9F\xFC\x05\x9E\x38\xEA\xEE\xE8", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xEC\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", .gcm_auth = 0, .input_len = 16, .input = (uint8_t *)"\x12\x38\xA3\x84\xE5\xF4\xDB\x19\xC8\xF4\x5F\x7F\xE1\xCF\x5D\x39", .output_len = 16, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x54\xC1\x53\x8A\x66\xF0\x27\x2B\xA7\x4E\x1D\xC6\xA3\x96\xAA\x85";
		is(len, (size_t)16, "expected length");
		ok_memcmp(exp_result, wksp, 16, "expected result");
	}
	/* CAVS_VECTOR_XTS_FINISH */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_XTS_FINISH, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_XTS, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_UNKNOWN, .key_len = 0, .key = (uint8_t *)"", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 0, .extra = (uint8_t *)"", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
	/* CAVS_VECTOR_XTS_DEC_INIT */
	{
		struct cavs_op_cipher v = {.vector = CAVS_VECTOR_XTS_DEC_INIT, .cipher = CAVS_CIPHER_ENC_AES, .mode = CAVS_CIPHER_MODE_XTS, .target = CAVS_TARGET_USER, .aes_is = CAVS_AES_IS_GEN, .key_len = 32, .key = (uint8_t *)"\xDE\xF5\xF7\xE7\xE0\xA7\x63\x6D\x12\x01\x08\xCD\x48\xBC\x06\x95\x73\x6A\x7B\xBA\xEC\xBE\x05\xA3\xBF\x08\x49\x09\xE5\x4B\xF2\xAD", .aad_len = 0, .aad = (uint8_t *)"", .tag_len = 0, .tag = (uint8_t *)"", .extra_len = 16, .extra = (uint8_t *)"\xD6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", .gcm_auth = 0, .input_len = 0, .input = (uint8_t *)"", .output_len = 0, };
		size_t len = 0;
		uint8_t *wksp = NULL;
		is(CAVS_STATUS_OK, cavs_dispatch(CAVS_TARGET_USER, v.vector, &v, &wksp, &len), "dispatch");
		const char *exp_result = "\x01";
		is(len, (size_t)1, "expected length");
		ok_memcmp(exp_result, wksp, 1, "expected result");
	}
